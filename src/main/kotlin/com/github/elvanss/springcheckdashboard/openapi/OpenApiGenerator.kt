package com.github.elvanss.springcheckdashboard.openapi

import com.github.elvanss.springcheckdashboard.model.Endpoint.EndpointInfo
import com.github.elvanss.springcheckdashboard.services.endpoint.SpringEndpointDetector
import com.intellij.ide.scratch.ScratchFileService
import com.intellij.ide.scratch.ScratchRootType
import com.intellij.lang.Language
import com.intellij.openapi.application.ApplicationManager
import com.intellij.openapi.fileEditor.FileEditorManager
import com.intellij.openapi.module.Module as IdeaModule
import com.intellij.openapi.module.ModuleManager
import com.intellij.openapi.project.Project
import com.intellij.openapi.vfs.VirtualFile
import com.intellij.psi.*
import com.intellij.psi.search.GlobalSearchScope
import java.time.LocalDateTime
import java.util.*
import kotlin.collections.LinkedHashMap

class OpenApiGenerator {

    /** Generate ALL endpoints in project */
    fun generate(project: Project) {
        val endpoints = ApplicationManager.getApplication().runReadAction<List<EndpointInfo>> {
            ModuleManager.getInstance(project).modules
                .flatMap { SpringEndpointDetector().detectControllersForModule(it) }
                .flatMap { it.methods }
        }
        generateFromEndpoints(project, endpoints, "all")
    }

    /** Generate exactly one endpoint */
    fun generateSingle(project: Project, ep: EndpointInfo) {
        generateFromEndpoints(project, listOf(ep), safeSuffix(ep))
    }

    /** Generate for a collected list (e.g., controller/module selection) */
    fun generateForList(project: Project, endpoints: List<EndpointInfo>, label: String) {
        generateFromEndpoints(project, endpoints, label)
    }

    /** Optional: Generate for a specific IntelliJ Module */
    fun generateForModule(project: Project, module: IdeaModule) {
        val endpoints = ApplicationManager.getApplication().runReadAction<List<EndpointInfo>> {
            SpringEndpointDetector().detectControllersForModule(module).flatMap { it.methods }
        }
        generateFromEndpoints(project, endpoints, "module-${module.name}")
    }

    // ---------------- Core ----------------

    private fun generateFromEndpoints(project: Project, endpoints: List<EndpointInfo>, suffix: String) {
        val (json, fileName) = ApplicationManager.getApplication().runReadAction<Pair<String, String>> {
            val psiManager = PsiManager.getInstance(project)
            val resolveScope = GlobalSearchScope.allScope(project)

            val openapi = newOpenApiSkeleton(project)
            val paths = openapi["paths"] as LinkedHashMap<String, Any>
            val schemas = (openapi["components"] as Map<*, *>)["schemas"] as LinkedHashMap<String, Any>

            endpoints.forEach { ep ->
                val pathItem = paths.getOrPut(ep.path) { LinkedHashMap<String, Any>() } as LinkedHashMap<String, Any>
                pathItem[ep.httpMethod.lowercase(Locale.ROOT)] =
                    buildOperation(ep, schemas, psiManager, resolveScope)
            }

            toJson(openapi) to "openapi-$suffix-${System.currentTimeMillis()}.json"
        }

        ApplicationManager.getApplication().invokeLater {
            ApplicationManager.getApplication().runWriteAction {
                val lang = resolveJsonLanguageOrPlain()
                val vFile: VirtualFile? = ScratchRootType.getInstance().createScratchFile(
                    project, fileName, lang, json, ScratchFileService.Option.create_new_always
                )
                if (vFile != null) {
                    FileEditorManager.getInstance(project).openFile(vFile, true)
                }
            }
        }
    }

    fun newOpenApiSkeleton(project: Project) = linkedMapOf<String, Any>(
        "openapi" to "3.0.3",
        "info" to mapOf(
            "title" to "${project.name} API",
            "version" to "0.1.0",
            "description" to "Generated by SpringCheck Dashboard @ ${LocalDateTime.now()}"
        ),
        "paths" to LinkedHashMap<String, Any>(),
        "components" to linkedMapOf("schemas" to LinkedHashMap<String, Any>())
    )

    private fun safeSuffix(ep: EndpointInfo): String {
        val p = ep.path.replace("/", "_").replace("{", "").replace("}", "")
            .replace(Regex("[^A-Za-z0-9_\\-]"), "")
        return "${ep.httpMethod.lowercase(Locale.ROOT)}$p-${ep.methodName}"
    }

    // ---------------- Build operation & types ----------------

    private fun buildOperation(
        ep: EndpointInfo,
        schemas: LinkedHashMap<String, Any>,
        psiManager: PsiManager,
        resolveScope: GlobalSearchScope
    ): Map<String, Any> {
        val pm = ep.targetElement as? PsiMethod
        val params = mutableListOf<Map<String, Any>>()
        var requestBody: Map<String, Any>? = null
        var responseSchema: Map<String, Any> = mapOf("type" to "string")

        // Parameters
        pm?.parameterList?.parameters?.forEach { p ->
            val schema = resolveType(p.type, schemas, psiManager, resolveScope)
            val isPath = p.hasAnnotation("org.springframework.web.bind.annotation.PathVariable")
            val isQuery = p.hasAnnotation("org.springframework.web.bind.annotation.RequestParam")
            val isBody  = p.hasAnnotation("org.springframework.web.bind.annotation.RequestBody")
            when {
                isPath -> params += parameterObject(p.name, "path", true, schema)
                isQuery -> params += parameterObject(p.name, "query", false, schema)
                isBody -> requestBody = bodyObject(schema)
                else -> {
                    if (isPrimitiveLike(p.type)) params += parameterObject(p.name, "query", false, schema)
                    else requestBody = bodyObject(schema)
                }
            }
        }

        // Response schema
        pm?.returnType?.let { responseSchema = resolveType(it, schemas, psiManager, resolveScope) }

        val responses = mapOf(
            "200" to mapOf(
                "description" to "OK",
                "content" to mapOf("application/json" to mapOf("schema" to responseSchema))
            )
        )

        val op = linkedMapOf<String, Any>(
            "operationId" to (pm?.name ?: ep.methodName),
            "summary" to "${ep.httpMethod} ${ep.path}",
            "responses" to responses
        )
        if (params.isNotEmpty()) op["parameters"] = params
        if (requestBody != null) op["requestBody"] = requestBody!!
        return op
    }

    private fun parameterObject(name: String, `in`: String, required: Boolean, schema: Map<String, Any>) =
        mapOf("name" to name, "in" to `in`, "required" to required, "schema" to schema)

    private fun bodyObject(schema: Map<String, Any>) =
        mapOf("required" to true, "content" to mapOf("application/json" to mapOf("schema" to schema)))

    private fun isPrimitiveLike(t: PsiType): Boolean {
        return t is PsiPrimitiveType || t.canonicalText in setOf(
            "java.lang.String", "java.lang.Integer", "java.lang.Long", "java.lang.Double",
            "java.lang.Float", "java.lang.Boolean", "java.lang.Short", "java.lang.Byte",
            "java.time.Instant", "java.time.LocalDate", "java.time.LocalDateTime"
        )
    }

    private fun resolveType(
        type: PsiType,
        schemas: LinkedHashMap<String, Any>,
        psiManager: PsiManager,
        resolveScope: GlobalSearchScope,
        depth: Int = 0
    ): Map<String, Any> {
        if (depth > 6) return mapOf("type" to "object")

        if (type is PsiPrimitiveType) {
            return when (type.canonicalText) {
                "int", "short", "byte" -> mapOf("type" to "integer", "format" to "int32")
                "long" -> mapOf("type" to "integer", "format" to "int64")
                "float" -> mapOf("type" to "number", "format" to "float")
                "double" -> mapOf("type" to "number", "format" to "double")
                "boolean" -> mapOf("type" to "boolean")
                "char" -> mapOf("type" to "string")
                else -> mapOf("type" to "string")
            }
        }

        val qn = type.canonicalText
        when (qn) {
            "java.lang.String", "char", "java.lang.Character" -> return mapOf("type" to "string")
            "java.lang.Boolean" -> return mapOf("type" to "boolean")
            "java.lang.Integer", "java.lang.Short", "java.lang.Byte" -> return mapOf("type" to "integer", "format" to "int32")
            "java.lang.Long" -> return mapOf("type" to "integer", "format" to "int64")
            "java.lang.Float" -> return mapOf("type" to "number", "format" to "float")
            "java.lang.Double" -> return mapOf("type" to "number", "format" to "double")
            "java.time.Instant", "java.time.LocalDateTime" -> return mapOf("type" to "string", "format" to "date-time")
            "java.time.LocalDate" -> return mapOf("type" to "string", "format" to "date")
            "void", "java.lang.Void" -> return mapOf("type" to "string")
        }

        // Array
        if (type is PsiArrayType) {
            val item = resolveType(type.componentType, schemas, psiManager, resolveScope, depth + 1)
            return mapOf("type" to "array", "items" to item)
        }

        // Collections / Map
        if (type is PsiClassType) {
            val resolved = type.resolve()
            val rawFqn = resolved?.qualifiedName

            if (rawFqn == "java.util.List" || rawFqn == "java.util.Set" || rawFqn == "java.util.Collection") {
                val itemType = type.parameters.firstOrNull() ?: PsiType.getJavaLangObject(psiManager, resolveScope)
                return mapOf("type" to "array", "items" to resolveType(itemType, schemas, psiManager, resolveScope, depth + 1))
            }
            if (rawFqn == "java.util.Map") {
                val vType = type.parameters.getOrNull(1) ?: PsiType.getJavaLangObject(psiManager, resolveScope)
                return mapOf(
                    "type" to "object",
                    "additionalProperties" to resolveType(vType, schemas, psiManager, resolveScope, depth + 1)
                )
            }

            // DTO object
            val cls = resolved ?: return mapOf("type" to "object")
            val name = cls.name ?: cls.qualifiedName ?: "AnonymousDto${schemas.size}"

            if (!schemas.containsKey(name)) {
                val props = LinkedHashMap<String, Any>()
                cls.allFields
                    .filter { f -> !f.hasModifierProperty(PsiModifier.STATIC) }
                    .forEach { f ->
                        props[f.name] = resolveType(f.type, schemas, psiManager, resolveScope, depth + 1)
                    }
                val schemaObj = linkedMapOf<String, Any>("type" to "object")
                if (props.isNotEmpty()) schemaObj["properties"] = props
                schemas[name] = schemaObj
            }
            return mapOf("\$ref" to "#/components/schemas/$name")
        }

        return mapOf("type" to "object")
    }

    // ----- Pretty JSON writer -----
    private fun toJson(value: Any?): String = toJsonPretty(value, 0)

    private fun toJsonPretty(value: Any?, indent: Int): String {
        return when (value) {
            null -> "null"
            is String -> "\"${escape(value)}\""
            is Number, is Boolean -> value.toString()
            is Map<*, *> -> {
                if (value.isEmpty()) return "{}"
                val sb = StringBuilder()
                sb.append("{\n")
                val it = value.entries.iterator()
                while (it.hasNext()) {
                    val (k, v) = it.next()
                    sb.append("  ".repeat(indent + 1))
                    sb.append("\"").append(escape(k.toString())).append("\": ")
                    sb.append(toJsonPretty(v, indent + 1))
                    if (it.hasNext()) sb.append(",")
                    sb.append("\n")
                }
                sb.append("  ".repeat(indent)).append("}")
                sb.toString()
            }
            is Iterable<*> -> {
                val list = value.toList()
                if (list.isEmpty()) return "[]"
                val sb = StringBuilder()
                sb.append("[\n")
                for (i in list.indices) {
                    sb.append("  ".repeat(indent + 1))
                    sb.append(toJsonPretty(list[i], indent + 1))
                    if (i < list.lastIndex) sb.append(",")
                    sb.append("\n")
                }
                sb.append("  ".repeat(indent)).append("]")
                sb.toString()
            }
            else -> "\"${escape(value.toString())}\""
        }
    }

    private fun escape(s: String) = buildString {
        for (c in s) {
            when (c) {
                '\\' -> append("\\\\")
                '"' -> append("\\\"")
                '\n' -> append("\\n")
                '\r' -> append("\\r")
                '\t' -> append("\\t")
                else -> append(c)
            }
        }
    }

    // JSON Language (or PlainText fallback)
    private fun resolveJsonLanguageOrPlain(): Language {
        return try {
            val cls = Class.forName("com.intellij.json.JsonLanguage")
            val field = cls.getField("INSTANCE")
            field.get(null) as Language
        } catch (_: Throwable) {
            Class.forName("com.intellij.openapi.fileTypes.PlainTextLanguage")
                .getField("INSTANCE")
                .get(null) as Language
        }
    }
}
